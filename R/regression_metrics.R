#' @include error_checking.R

# Begin Metrics
#
#' Performance Metrics for a Classification Model
#'
#' It computes the classic performance metrics of a scoring model, including AUC, KS and all the relevant ones
#' from the classification matrix at a specific threshold or cutoff.
#' @param dataset Data frame.
#' @param prediction Classifier. A value generated by a classification model (Must be numeric).
#' @param actualclass Binary variable (0/1) that represents the actual class (Must be numeric).
#' @param cutoff Point at wich the classifier splits (predicts) the actual class (Must be numeric).
#' If not specified, it will be estimated by using the maximum value of Youden J (Sensitivity+Specificity-1).
#' If not found in the data frame, it will take the closest lower value.
#' @param report Indicator defined by user. 1: Show report (Default), 0: Do not show report.
#' @param plot Specifies the plot to be shown for overall evaluation. It has three options: 'auc' shows the ROC curve,
#' 'ks' shows the cumulative distribution of the actual class and its maximum difference (KS Statistic),
#' and 'none' (Default).
#' @param returndf Option for the user to save the data frame behind the metrics. 1: Show data frame, 0:
#' Do not show (Default).
#' @return The command \code{smbinning.metrics} returns a report with classic performance metrics of a
#' classification model.
#' @examples
#' # Load library and its dataset
#' library(smbinning) # Load package and its data
#'
#' # Example: Metrics Credit Score 1
#' smbinning.metrics(
#'   dataset = smbsimdf1,
#'   prediction = "cbs1",
#'   actualclass = "fgood",
#'   report = 1
#' ) # Show report
#' smbinning.metrics(
#'   dataset = smbsimdf1,
#'   prediction = "cbs1",
#'   actualclass = "fgood",
#'   cutoff = 600,
#'   report = 1
#' ) # User cutoff
#' smbinning.metrics(
#'   dataset = smbsimdf1,
#'   prediction = "cbs1",
#'   actualclass = "fgood",
#'   report = 0,
#'   plot = "auc"
#' ) # Plot AUC
#' smbinning.metrics(
#'   dataset = smbsimdf1,
#'   prediction = "cbs1",
#'   actualclass = "fgood",
#'   report = 0, plot = "ks"
#' ) # Plot KS
#'
#' # Save table with all details of metrics
#' cbs1metrics <- smbinning.metrics(
#'   dataset = smbsimdf1,
#'   prediction = "cbs1",
#'   actualclass = "fgood",
#'   report = 0,
#'   returndf = 1
#' ) # Save metrics details
#' @export
smbinning.metrics <- function(dataset,
                              prediction,
                              actualclass,
                              cutoff = NA,
                              report = 1,
                              plot = "none",
                              returndf = 0) {
  requireNamespace("assertthat")

  # Find Column for actualclass
  i <- which(names(dataset) == actualclass)

  # Find Column for prediction
  j <- which(names(dataset) == prediction)

  tryCatch(
    {
      assert_that(is.data.frame(df))
    },
    error = function(e) {
      message("Data df not a dataframe.")
      return(NA)
    }
  )

  if (!is.na(cutoff) & !is.numeric(cutoff)) {
    return("'cutoff' must be numeric.")
  } else if (!is.numeric(dataset[, which(names(dataset) == prediction)])) {
    return("'prediction' not found.")
  } else if (max(dataset[, i], na.rm = TRUE) != 1 |
    min(dataset[, i], na.rm = TRUE) != 0) {
    return("'actualclass' must be binary (0/1).")
  } else if (length(unique(na.omit(dataset[, c(actualclass)]))) != 2) {
    return("'actualclass' must be binary (0/1).")
  } else if (report != 1 & report != 0) {
    return("'report' must be 0 (Deactivated) or 1 (Activated).")
  } else if (returndf != 1 & returndf != 0) {
    return("'df' must be 0 (Deactivated) or 1 (Activated).")
  } else if (plot != "auc" & plot != "ks" & plot != "none") {
    return("'plot' options are: 'auc', 'ks' or 'none'.")
  } else if (!is.na(cutoff) &
    (max(dataset[, j], na.rm = TRUE) < cutoff |
      min(dataset[, j], na.rm = TRUE) > cutoff)) {
    return("'cutoff' out of range.")
  }
  else {
    # Create table and its basic structure
    # Only Score and class
    dataset <- dataset[, c(prediction, actualclass)]

    # Missing rows
    nmiss <- nrow(dataset) - nrow(na.omit(dataset))

    # Complete Cases Only
    dataset <- na.omit(dataset)

    # Group by prediction
    df <- table(dataset[, c(prediction)], dataset[, c(actualclass)])

    # Prediction becomes rowname
    df <- as.data.frame.matrix(df)

    # Bring rowname as a column with values
    df$Prediction <- rownames(df)
    rownames(df) <- NULL
    names(df)[names(df) == "0"] <- "CntBad"
    names(df)[names(df) == "1"] <- "CntGood"

    # Reorder
    df <- df[, c("Prediction", "CntGood", "CntBad")]
    df$CntTotal <- df$CntBad + df$CntGood

    # Cumulative Ascending
    df$CumAscGood <- cumsum(df$CntGood)
    df$CumAscBad <- cumsum(df$CntBad)
    df$CumAscTotal <- cumsum(df$CntTotal)

    # Totals for upcoming calculations
    SumRecords <- sum(df$CntTotal)
    SumGoods <- sum(df$CntGood)
    SumBads <- sum(df$CntBad)

    # Cumulative Descending
    df$CumDescGood <- NA
    c <- which(names(df) == "CumDescGood")
    df[1, c] <- sum(df$CntGood)
    for (i in 2:nrow(df)) {
      df[i, c] <- df[1, c] - df[i - 1, 5]
    }

    df$CumDescBad <- NA
    c <- which(names(df) == "CumDescBad")
    df[1, c] <- sum(df$CntBad)
    for (i in 2:nrow(df)) {
      df[i, c] <- df[1, c] - df[i - 1, 6]
    }

    df$CumDescTotal <- NA
    c <- which(names(df) == "CumDescTotal")
    df[1, c] <- sum(df$CntTotal)
    for (i in 2:nrow(df)) {
      df[i, c] <- df[1, c] - df[i - 1, 7]
    }

    # Cumulative Percent (Column/Vertical Calculation)
    df$PctCumDescTotal <- df$CumDescTotal / SumRecords

    # Good/Bad Rates (Row/Horizontal Calculation)
    df$GoodRateRow <- df$CntGood / df$CntTotal
    df$BadRateRow <- df$CntBad / df$CntTotal
    df$GoodRateDesc <- df$CumDescGood / df$CumDescTotal
    df$BadRateDesc <- df$CumDescBad / df$CumDescTotal

    # Cumulative Percentage
    df$PctCumAscGood <- df$CumAscGood / SumGoods
    df$PctCumAscBad <- df$CumAscBad / SumBads

    # Remove ascending stats to avoid confusion
    df$CumAscGood <- NULL
    df$CumAscBad <- NULL
    df$CumAscTotal <- NULL

    # TN and FN
    df$FN <- SumGoods - df$CumDescGood
    df$TN <- SumBads - df$CumDescBad

    # Accuracy
    df$Accuracy <-
      (df$CumDescGood + df$TN) / (df$TN + df$FN + df$CumDescGood +
        df$CumDescBad)

    # Specificity, Sensitivity
    df$Sensitivity <- df$CumDescGood / (df$CumDescGood + df$FN)
    df$Specificity <- df$TN / (df$TN + df$CumDescBad)

    # False Positive Rate
    df$FalPosRate <- df$CumDescBad / (df$CumDescBad + df$TN)

    # Precision
    df$Precision <-
      df$CumDescGood / (df$CumDescGood + df$CumDescBad)

    # Inverse Precision
    df$InvPrecision <- df$TN / (df$FN + df$TN)

    # Youden Index
    df$YoudenJ <- df$Sensitivity + df$Specificity - 1
    # max(df$YoudenJ)

    # Optimal Cutoff
    optcut <- df[df$YoudenJ == max(df$YoudenJ), ]$Prediction
    df$YoudenJ <- NULL
    optcutcomment <- " (Optimal)"

    # If cutoff is specified
    if (!is.na(cutoff)) {
      if ((cutoff %in% df$Prediction) == FALSE) {
        optcut <- df[which.min(abs(as.numeric(df$Prediction) - cutoff)), 1]
        optcutcomment <- paste0(" (", cutoff, " Not Found)")
      } else {
        optcut <- cutoff
        optcutcomment <- " (User Defined)"
      }
    }

    # For AUC Calculation (Trapezoid Method)
    df$TPR <- df$Sensitivity
    df$FPR <- 1 - df$Specificity
    df$MgAUC <- 0
    a <- which(names(df) == "MgAUC")
    f <- which(names(df) == "FPR")
    t <- which(names(df) == "TPR")
    for (i in 1:(nrow(df) - 1)) {
      df[i, a] <- 0.5 * (df[i, t] + df[i + 1, t]) * (df[i, f] - df[i + 1, f])
    }

    # AUC
    auc <- sum(df$MgAUC)
    df$TPR <- NULL
    df$FPR <- NULL
    df$MgAUC <- NULL

    # AUC Evaluation
    auceval <- ifelse(auc < 0.6, "Unpredictive",
      ifelse(auc < 0.7, "Poor",
        ifelse(
          auc < 0.8, "Fair",
          ifelse(auc < 0.9, "Good", "Excellent")
        )
      )
    )

    # KS
    df$MgKS <- abs(df$PctCumAscGood - df$PctCumAscBad)
    ks <- as.numeric(max(df$MgKS))
    scoreks <- as.numeric(df[df$MgKS == ks, ]$Prediction)
    cgks <- as.numeric(df[df$MgKS == ks, ]$PctCumAscGood)
    cbks <- as.numeric(df[df$MgKS == ks, ]$PctCumAscBad)
    df$MgKS <- NULL

    # KS Evaluation
    kseval <- ifelse(ks < 0.3, "Unpredictive",
      ifelse(ks < 0.4, "Fair",
        ifelse(
          ks < 0.5, "Good",
          ifelse(
            ks < 0.6,
            "Excellent",
            ifelse(ks < 0.7, "Awesome", "That Good. Really?")
          )
        )
      )
    )

    # If report is activated (report = 1)
    if (report == 1) {
      # Confusion Matrix Components
      tp <- df[df$Prediction == optcut, ]$CumDescGood
      fp <- df[df$Prediction == optcut, ]$CumDescBad
      fn <- df[df$Prediction == optcut, ]$FN
      tn <- df[df$Prediction == optcut, ]$TN
      p <- SumGoods
      n <- SumBads

      recsabovecutoff <-
        df[df$Prediction == optcut, ]$CumDescTotal / SumRecords
      goodrate <- df[df$Prediction == optcut, ]$GoodRateDesc
      badrate <- df[df$Prediction == optcut, ]$BadRateDesc

      # Report on Metrics
      admetrics <- character()
      admetrics <- paste0(admetrics, "\n")
      admetrics <-
        paste0(admetrics, "  Overall Performance Metrics \n")
      admetrics <- paste0(
        admetrics,
        "  -------------------------------------------------- \n"
      )
      admetrics <- paste0(
        admetrics,
        "                    KS : ",
        sprintf("%.4f", round(ks, 4)),
        " (",
        kseval,
        ")\n"
      )

      admetrics <- paste0(
        admetrics,
        "                   AUC : ",
        sprintf("%.4f", round(auc, 4)),
        " (",
        auceval,
        ")\n"
      )

      admetrics <- paste0(admetrics, "\n")
      admetrics <- paste0(
        admetrics,
        "  Classification Matrix \n"
      )
      admetrics <- paste0(
        admetrics,
        "  -------------------------------------------------- \n"
      )
      admetrics <- paste0(
        admetrics,
        "           Cutoff (>=) : ",
        round(as.numeric(optcut), 4),
        optcutcomment,
        "\n"
      )
      admetrics <-
        paste0(admetrics, "   True Positives (TP) : ", tp, "\n")
      admetrics <-
        paste0(admetrics, "   False Positives (FP) : ", fp, "\n")
      admetrics <-
        paste0(admetrics, "   False Negatives (FN) : ", fn, "\n")
      admetrics <-
        paste0(admetrics, "   True Negatives (TN) : ", tn, "\n")
      admetrics <-
        paste0(admetrics, "   Total Positives (P) : ", p, "\n")
      admetrics <-
        paste0(admetrics, "   Total Negatives (N) : ", n, "\n")
      admetrics <- paste0(admetrics, "\n")
      admetrics <-
        paste0(admetrics, "  Business/Performance Metrics \n")
      admetrics <-
        paste0(
          admetrics,
          "  -------------------------------------------------- \n"
        )
      admetrics <- paste0(
        admetrics,
        "      %Records>=Cutoff : ",
        sprintf("%.4f", round(recsabovecutoff, 4)),
        "\n"
      )
      admetrics <- paste0(
        admetrics,
        "             Good Rate : ",
        sprintf("%.4f", round(goodrate, 4)),
        " (Vs ",
        sprintf("%.4f", round(SumGoods / SumRecords, 4)),
        " Overall)\n"
      )
      admetrics <- paste0(
        admetrics,
        "              Bad Rate : ",
        sprintf("%.4f", round(badrate, 4)),
        " (Vs ",
        sprintf("%.4f", round(SumBads / SumRecords, 4)),
        " Overall)\n"
      )
      admetrics <- paste0(
        admetrics,
        "        Accuracy (ACC) : ",
        sprintf("%.4f", round((tp + tn) / (tp + fp + tn + fn), 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        "     Sensitivity (TPR) : ",
        sprintf("%.4f", round(tp / p, 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        " False Neg. Rate (FNR) : ",
        sprintf("%.4f", round(fn / p, 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        " False Pos. Rate (FPR) : ",
        sprintf("%.4f", round(fp / n, 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        "     Specificity (TNR) : ",
        sprintf("%.4f", round(tn / n, 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        "       Precision (PPV) : ",
        sprintf("%.4f", round(tp / (tp + fp), 4)),
        "\n"
      )
      admetrics <- paste0(
        admetrics,
        "  False Discovery Rate : ",
        sprintf("%.4f", round(fp / (tp + fp), 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        "    False Omision Rate : ",
        sprintf("%.4f", round(fn / (fn + tn), 4)),
        "\n"
      )

      admetrics <- paste0(
        admetrics,
        "  Inv. Precision (NPV) : ",
        sprintf("%.4f", round(tn / (fn + tn), 4)),
        "\n"
      )

      admetrics <- paste0(admetrics, "\n")
      admetrics <- paste0(
        admetrics,
        "  Note: ",
        nmiss,
        " rows deleted due to missing data.\n"
      )

      admetrics <- paste0(admetrics, "\n")
      admetrics <- gsub(", ", "", admetrics)

      # Metric report
      cat(admetrics)
    } # End if for report

    # AUC Plot
    if (plot == "auc") {
      plot(
        NULL,
        xlim = c(0, 1),
        ylim = c(0, 1),
        main = "ROC Curve",
        xlab = "1-Specificity",
        ylab = "Sensitivity"
      )
      grid()
      points(
        1 - df$Specificity,
        df$Sensitivity,
        pch = 21,
        col = "grey25",
        bg = "grey25"
      )
      abline(0, 1, col = "grey50", lty = 2)
      text(0.8, 0.1, paste0("AUC : ", round(100 * auc, 2), "%"))
    }

    # KS Plot
    if (plot == "ks") {
      plot(
        NULL,
        xlim = c(as.numeric(min(
          df$Prediction
        )), as.numeric(max(
          df$Prediction
        ))),
        ylim = c(0, 1),
        main = "Cumulative Distribution of Goods/Bads",
        xlab = prediction,
        ylab = "Cumulative Distribution"
      )
      grid()
      text(as.numeric(min(df$Prediction)),
        0.95,
        "* Bads",
        pos = 4,
        col = "firebrick"
      )
      text(as.numeric(min(df$Prediction)),
        0.90,
        "* Goods",
        pos = 4,
        col = "dodgerblue4"
      )
      segments(
        scoreks,
        cgks,
        scoreks,
        cbks,
        lty = 2,
        lwd = 2,
        col = "grey50"
      )
      points(
        df$Prediction,
        df$PctCumAscBad,
        pch = 21,
        col = "firebrick",
        bg = "firebrick"
      )
      points(
        df$Prediction,
        df$PctCumAscGood,
        pch = 21,
        col = "dodgerblue4",
        bg = "dodgerblue4"
      )
      text(
        0.95 * as.numeric(max(df$Prediction)), 0.1,
        paste0(
          "KS : ",
          round(100 * ks, 2), "%"
        )
      )
    }

    if (returndf == 1) {
      return(df)
    }
  } # Close else
} # Close function
# Ends Metrics






# Ini: PSI
#' Population Stability Index
#'
#' Often models are developed using multiple periods in time for a number of reasons.
#' For example, to avoid seasonality, to increase the size of the population, and some others.
#' With a metrics like the Population Stability Index (PSI), users can check if there is
#' a significant variation in the distribution of a certain feature by partition (usually time)
#' using the first one as the reference.
#' @param df Data frame.
#' @param y Column name the indicates the different partitions.
#' @param x Feature to be evaluated in terms of stability (It must be factor).
#' @return Three crosstabs by feature and period that show the frequency (psicnt),
#' percentage (psipct) and PSI (psimg), and a plot for the analyzed characteristic.
#' @examples
#' # Load library and its dataset
#' library(smbinning)
#'
#' # Check stability for income
#' smbinning.psi(
#'   df = smbsimdf1,
#'   y = "period",
#'   x = "inc"
#' )
#' @export
smbinning.psi <- function(df, y, x) {
  i <- which(names(df) == x)
  j <- which(names(df) == y)

  tryCatch(
    {
      assertthat::assert_that(is.data.frame(df))
    },
    error = function(e) {
      message("Data df not a dataframe.")
      return(NA)
    }
  )

  if (identical(i, integer(0))) {
    return(stop(paste("Characteristic", x, "not found")))
  }
  else if (identical(j, integer(0))) {
    return(stop(paste("Characteristic", y, "not found")))
  }
  else if (class(df[, i]) != "factor") {
    return(stop("x must be formatted as factor"))
  }
  else {
    # Table with counts including NA
    psicnt <- table(df[, i], df[, j], useNA = "ifany")

    # Remove Scientific Notation
    options(scipen = 999)

    # Table with column percentage
    psipct <- prop.table(psicnt, margin = 2)

    # Shell for PSI table
    psimg <- psipct

    # Number of columns (Periods)
    n <- ncol(psipct)

    # Number of rowa (Periods)
    m <- nrow(psipct)

    # Step 1: PSI=0 for first column
    psimg[, 1] <- 0

    # PSI Period VS First Period
    for (k in 2:n) {
      for (l in 1:m) {
        if (psipct[l, 1] > 0 & psipct[l, k] > 0) {
          psimg[l, k] <-
            round((psipct[l, k] - psipct[l, 1]) * log(psipct[l, k] / psipct[l, 1]), 8)
        }
        else {
          psimg[l, k] <- 0
        }
      }
    }

    psimg <- rbind(psimg, PSI = colSums(psimg))

    # Table with Mg PSI
    psimg <- as.table(psimg)

    # Extract total PSI only
    psitable <- psimg[nrow(psimg), ]
    psitable <- as.data.frame(psitable)

    # Plot
    # Create column "Partition"
    psitable$Partition <- rownames(psitable)

    # Remove rownames
    rownames(psitable) <- NULL

    # Rename columns
    names(psitable) <- c("PSI", "Partition")

    # Reorder
    psitable <- psitable[, c("Partition", "PSI")]

    maxpsi <- max(psitable$PSI)
    psiylim <- ifelse(maxpsi < 0.25, 0.25, maxpsi)
    plot(
      psitable$PSI,
      main = paste("Stability:", x),
      xlab = paste("Partition:", y),
      ylab = "PSI",
      ylim = c(0, psiylim),
      pch = 19,
      col = "black",
      xaxt = "n"
    )

    # Remove x axis values
    abline(h = 0.1, lty = 2)
    abline(h = 0.25, lty = 2)
    axis(1, at = 1:nrow(psitable), psitable$Partition) # Add period

    list(
      psicnt = psicnt,
      psipct = psipct,
      psimg = psimg
    )
  }
}
# End: PSI
